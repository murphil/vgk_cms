业务流引擎的性质
  - 业务流引擎实现为 ContentRender 的组件
  - 业务流可以形象的看做由箭头和圆圈组成的图
  - 圆圈之间由箭头相连
  - 从任意一个圆圈出发，沿着箭头的方向，总能走到终点。(不存在环路)
  - 从实际需求出发，设终点为唯一。(从任意一个圆圈出发，沿着箭头方向，总会走到唯一的一个圆圈)
  - 预分析DAG，并存储元信息
    - 初始状态
      - 默认入口
    - 合法性
      - 所有等待之后圆圈都设置为等待(不包含弱依赖项)
      - 终点是否唯一
    - 绘图信息
      - 终点圆圈。放置在最右侧，画图里从右向左画
      - 最长路径。 决定画布宽度
      - dag宽度。决定画布高度
  - 业务流分为两种，线性和DAG。
    - 因为DAG的涉及图算法，开销比较大，一般情况下线性工作流就足够了
    - 线性容器实现简单，眼前正好用得上。并且利用它先把坑填上
    - DAG 有全局变量表，使用圆圈的Uri为名存储所有结果的值
    - 在模板中指定Content Render接收的变量，使用 ${xxx} 的格式
      - 在传给 Content Render 之前进行变量替换操作。注意类型
  - 圆圈做为容器，其中放置的实际业务单元，假设它是方框。
    - 圆圈中可以放入其它DAG(圆圈和箭头)，这是为了方便设置背景工作流。
      - 如身份验证，并不适合做为起点圆圈，那样的话每次验证都要从头开始
      - 设置有两个圆圈的线性业务流，验证后进入到第二个圆圈，圆圈内部放置真正的业务流
      - 这样的话，无论任何情况下，最外层要有一个最大的圆圈，圆圈状态为当前业务流的状态
    - 有一个初始的最外层的圆圈，用来和外部组件（ContentRender）交互
  - 圆圈有Uri和描述 (ContentRender 并不适合放在这里，而要放在方框里)
    - Uri做为结果的变量名
    - 标题并无必要，取消
  - 圆圈有依赖项列表，就是它自身拥有箭头尾部的圆圈(入度)
    - 实际编程中没有必要为箭头设定一种数据结构(这是领接表表示法)
    - 依赖项状态为成功时，可以取其结果
    - 依赖项是一个二维列表
      - 外层列表中的每一项都要完成
      - 内层列表中的只要完成一项即可。做为OR箭头
      - 内层列表中只有一项的话，则此项是必须完成的
  - 圆圈有弱依赖项列表，可在用户干预下形成临时环路
    - 对图进行预分析时，不检查弱依赖项
  - 圆圈有等待(每次重试的时间列表)，成功(含结果)，失败(含原因)三种状态。根据状态来确定进程。
    - 方框接受所有依赖项的成功结果为输入
    - 如果当前状态为等待，并且所有依赖项状态为成功，则在 ContentRender 中显示将要进行的操作
      - 可以考虑设置 OR 箭头，即依赖项中有一个成功的即可继续执行
    - 方框执行完毕
      - 成功则把它所处的圆圈状态设置为成功，结果设置为执行结果
        - 展示/确认的流程，如用户协议，则是用户确认后直接设置为成功
      - 失败则把它所处的圆圈状态设置为失败，原因设置为失败原因
        - 失败可以在用户的干预下设置为等待，重新执行
        - 用户干预应提供选项，可以把当前/之前多级设置为等待，或者把当前/全部设置为等待
        - 这里实际是在用户的干预下形成了环路，应放宽对于DAG的限制。增加弱依赖项列表，渲染时不显示，用户干预时显示
    - 圆圈提供接口，以便方框能设计圆圈的状态

数据设置
  - 新建WorkFlowTemplate表 或者 upload/workflow 中放置工作流模板
    - 把模板放到数据库中或许更好
      - 模板一旦实例化，便被依赖，在依赖项删除前是不可删除和改动的
        - 数据库约束可以更好的表达不可删除
        - 不可改动的话，同名模板就要有不同的版本需要管理。每次改动都创建新的版本。量会比较大，在数据库中方便管理
        - 用户开始一个工作流，默认实例化最高版本的模板
      - 放在文件中的主要好处是便于修改
    - 模板中不包含状态数据(等待/成功/失败 及对应结果)。
    - 模板中包含: 标题，描述，依赖项列表，圆圈&箭头/方框，
  - 数据库中新建一个 workflow 的流水表存储工作流的状态。
    - 与用户关联
    - 与模板关联
    - 有创建和更新时间
      - 创建即开始工作流
      - 更新即最近一步工作
  - 数据库中新建一个 MailBox 表
    - 邮件类型有： 审批/站内短信/游客留言 等
      - 游客留言有用户名，无用户ID参照

业务单元(方框)
  - 网络请求: 取上一节点容器的成功结果，填写信息，向某地址发送请求
    - 正确设置当前容器状态为成功，设置结果。
    - 错误设置状态为失败，设置失败信息。
    - 样例: ContentRender 显示用户名密码，用户输入提交后向某地址提交请求。然后设置结果
  - 审批流程: 取上一节点容器的成功结果，填写信息，向某用户发送邮件
    - 应在数据库中设置用户信箱(mailbox)表
      - 与发送者和接收者关联
      - 类型为‘站内邮件/审批’
      - 有创建和更新时间
        - 创建即申请时间
        - 更新即审批时间
      - 接收者上线拉取邮箱内容，可以看到类型为审批的邮件。
      - 重入流程时，检查发送者的类型为审批的邮件，更新时间字段设置了则为已审批
    - 外部流程如网络请求，验证由外部负责。内部流程，则要考虑**防篡改**的问题
        - 可以去数据库中比对更新时间戳，但是要请求数据库，开销比较大
        - 或者使用HMAC对消息签名

涉及两种 ContentRender 组件，网络请求和站内邮件，分为两层:
  - 表单层。用户名/密码表单，邮件/接收者表单
  - 动作层。Post请求组件，站内邮件发送组件。
  - 通过事件/数据绑定把数据向上传播，直到遇到圆圈为止。